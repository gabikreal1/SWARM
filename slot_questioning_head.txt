"""
Minimal slot/questioning helper for SpoonOS agents.

Features:
- Defines a simple InputSlot schema and SlotFiller that suggests missing slots and clarifying questions.
- Uses SpoonMem0 long-term memory when available (per-user first, anonymized global fallback).
- Ranks missing slots with similarity-weighted voting and tool-required parameter priority.
- Provides a CLI-style demo at the bottom.
"""

from __future__ import annotations

import json
import logging
import math
import os
from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple

from spoon_ai.memory.mem0_client import SpoonMem0

logger = logging.getLogger(__name__)


# ----------------------------
# Data models
# ----------------------------


@dataclass(frozen=True)
class InputSlot:
    """Simple slot schema."""

    name: str
    description: str = ""
    question_template: str = "Could you provide your {slot}?"

    def make_question(self) -> str:
        return self.question_template.format(slot=self.name.replace("_", " "))


@dataclass
class TemplateRecord:
    """Stored template for few-shot style recall."""

    task_summary: str
    final_slots: Dict[str, Any]
    questions_asked: List[str]
    chosen_tool: str
    success: bool
    similarity: float = 1.0  # Mem0 wrapper doesn't expose score; default to 1.0.
    privacy: Optional[str] = None

    def to_text(self) -> str:
        payload = {
            "task_summary": self.task_summary,
            "final_slots": self.final_slots,
            "questions_asked": self.questions_asked,
            "chosen_tool": self.chosen_tool,
            "success": self.success,
            "privacy": self.privacy,
        }
        return json.dumps(payload, ensure_ascii=True)

    @staticmethod
    def from_text(blob: str, similarity: float = 1.0) -> Optional["TemplateRecord"]:
        try:
            data = json.loads(blob)
            return TemplateRecord(
                task_summary=str(data.get("task_summary", "")),
                final_slots=dict(data.get("final_slots") or {}),
                questions_asked=list(data.get("questions_asked") or []),
                chosen_tool=str(data.get("chosen_tool", "")),
                success=bool(data.get("success", False)),
                similarity=similarity,
                privacy=data.get("privacy"),
            )
        except Exception:
            logger.debug("Failed to parse stored template text: %s", blob)
            return None

    def build_query_text(self) -> str:
        """Combine fields for embedding-based similarity."""
        final_slots = {k: ("<filled>" if v else "<missing>") for k, v in self.final_slots.items()}
        return (
            f"summary: {self.task_summary}\n"
            f"tool: {self.chosen_tool}\n"
            f"slots: {json.dumps(final_slots, ensure_ascii=True)}"
        )

# ----------------------------
# Memory helpers
# ----------------------------


class TemplateMemory:
    """Handles storing and retrieving templates with per-user preference and global fallback."""

    def __init__(
        self,
        user_id: Optional[str],
        per_user_collection: str = "templates",
        global_collection: str = "global_templates",
    ) -> None:
        self.user_id = user_id
        self.user_mem = SpoonMem0(
            {
                "user_id": user_id,
                "collection": per_user_collection,
                "filters": {"user_id": user_id} if user_id else {},
            }
        )
        self.global_mem = SpoonMem0(
            {
                "collection": global_collection,
                "metadata": {"privacy": "anonymized"},
                # Mem0 requires at least one filter; use an agent_id marker plus anonymized user_id.
                "user_id": "anon_global",
                "filters": {"agent_id": "global_templates", "user_id": "anon_global"},
            }
        )

    def search(self, query: str, min_hits: int = 2) -> List[TemplateRecord]:
        """Search per-user first, then global anonymized fallback."""
        hits: List[TemplateRecord] = []

        # Per-user
        if self.user_mem.is_ready():
            hits = self._parse_results(self.user_mem.search_memory(query))

        # Global fallback if not enough
        if len(hits) < min_hits and self.global_mem.is_ready():
            global_hits = self._parse_results(self.global_mem.search_memory(query))
            # Tag privacy on global hits
            for h in global_hits:
                h.privacy = h.privacy or "anonymized"
            hits.extend(global_hits)

        return hits

    def store(self, record: TemplateRecord) -> None:
        """Store per-user (if available) and anonymized global copy."""
        if self.user_mem.is_ready():
            try:
                self.user_mem.add_text(record.to_text(), user_id=self.user_id)
            except Exception as exc:  # pragma: no cover - defensive
                logger.warning("Per-user template store failed: %s", exc)

        if self.global_mem.is_ready():
            global_copy = TemplateRecord(
                task_summary=record.task_summary,
                final_slots=record.final_slots,
                questions_asked=record.questions_asked,
                chosen_tool=record.chosen_tool,
                success=record.success,
                similarity=record.similarity,
                privacy="anonymized",
            )
            try:
                self.global_mem.add_text(
                    global_copy.to_text(),
                    metadata={"privacy": "anonymized"},
                )
            except Exception as exc:  # pragma: no cover - defensive
                logger.warning("Global template store failed: %s", exc)

    @staticmethod
    def _parse_results(results: Iterable[str]) -> List[TemplateRecord]:
        parsed: List[TemplateRecord] = []
        for raw in results or []:
            rec = TemplateRecord.from_text(raw)
            if rec:
                parsed.append(rec)
        return parsed


# ----------------------------
# Embedding helpers
# ----------------------------


class EmbeddingModel:
    """Embedding provider with OpenAI (if available) and a deterministic fallback."""

    def __init__(self, model: str = "text-embedding-3-small") -> None:
        self.model = model
        self.openai_client = self._try_openai()
        self.fallback_dim = 128

    def _try_openai(self):
        try:
            import openai  # type: ignore

            return openai.OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        except Exception:
            return None

    def embed(self, text: str) -> List[float]:
        if not text:
            return []
        if self.openai_client:
            try:
                resp = self.openai_client.embeddings.create(model=self.model, input=text)
                return list(resp.data[0].embedding)
            except Exception as exc:  # pragma: no cover - external call
                logger.debug("OpenAI embedding failed, falling back: %s", exc)
        return self._hash_embed(text)

    @staticmethod
    def _hash_embed(text: str, dim: int = 128) -> List[float]:
        """Deterministic lightweight embedding using hashing (fallback)."""
        vec = [0.0] * dim
        for token in text.lower().split():
            h = hash(token)
            idx = h % dim
            vec[idx] += 1.0
        return vec

    @staticmethod
    def cosine(a: Sequence[float], b: Sequence[float]) -> float:
        if not a or not b:
            return 0.0
        length = min(len(a), len(b))
        dot = sum(a[i] * b[i] for i in range(length))
        na = math.sqrt(sum(a[i] * a[i] for i in range(length)))
        nb = math.sqrt(sum(b[i] * b[i] for i in range(length)))
        if na == 0 or nb == 0:
            return 0.0
        return dot / (na * nb)


# ----------------------------
# Qdrant helpers
# ----------------------------


class QdrantTemplateStore:
    """Lightweight vector store for templates using Qdrant."""

    def __init__(
        self,
        embedder: EmbeddingModel,
        collection: str = "slot_templates",
        url: Optional[str] = None,
        api_key: Optional[str] = None,
    ) -> None:
        self.embedder = embedder
        self.collection = collection
        self.client = self._init_client(url, api_key)
        if self.client:
            self._ensure_collection()

    def _init_client(self, url: Optional[str], api_key: Optional[str]):
        try:
            from qdrant_client import QdrantClient  # type: ignore

            return QdrantClient(url=url or os.getenv("QDRANT_URL"), api_key=api_key or os.getenv("QDRANT_API_KEY"))
        except Exception as exc:
            logger.debug("Qdrant client init failed: %s", exc)
            return None
